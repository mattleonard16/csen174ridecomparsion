Implementation Best Practices
Before implementing the feature, prompt the user to explain anything unclear about the feature

For complex features, plan your approach first and confirm with the user

For complex features, if multiple approaches are possible, list pros and cons for each approach

Always run prettier on newly created files to ensure standard formatting

Always run turbo typecheck lint to ensure type checking and linting passes

Avoid classes where state is not required and prefer small, testable functions

Always write unit tests for complex algorithms

Prefer simple, testable functions

Prefer integration tests over excessive mocking

ALWAYS test new API routes with integration tests

NEVER put comments in code unless there are known caveats – prefer self-explaining code with clearly named vars

Prefer type over interface unless the latter is more readable or merging is required

Prefer branded types for IDs over simple string/number aliasing

e.g. type Brand<K, T extends string> = K & { __brand: T }

Only put functions in packages/shared if multiple packages are using them (e.g. api and web)

For the main database, types can be overridden in packages/shared/src/db-types.override.ts

e.g. autogenerated types show incorrect BigInt values – override to string manually

Writing Functions Best Practices
When evaluating whether a function is good:

Can you read the function and honestly follow what it's doing? If yes, stop here.

Does it have high cyclomatic complexity?

Are there standard data structures/algorithms that would make it easier to follow or more efficient?

Are there unused parameters?

Are there unnecessary type casts that could be moved to arguments?

Is the function name clear and does it follow conventions?

Is it testable without mocking core features (e.g. SQL, Redis)?

Does it have hidden/untracked dependencies or constants that should be arguments?

Brainstorm 3 better names to see if the current name is best.

Testing Best Practices
Unit tests should be grouped under describe(functionName)

Avoid hardcoded values

Adhere to the same standards as production code

Ensure tests actually test the described condition

NEVER write trivial tests just for coverage

Use expect.any(...) for flexible parameters

Prefer strong assertions like expect(result).toBeGreaterThan(0)

Test edge cases, invalid input, and boundary values

NEVER test conditions already caught by type checks

Prefer testing properties and invariants over one-off examples
Code Organization: 

app/ – Next.js 14+ App Router pages and API routes
app/api/compare-rides/ – Rideshare comparison API endpoint
app/page.tsx – Main landing page with hero section
app/layout.tsx – Root layout with metadata and PWA config
app/globals.css – Global styles and Tailwind base
components/ – Reusable React components
components/ui/ – Base UI components (Button, Card, Input, etc.)
components/ride-comparison-form.tsx – Main form component with search logic
components/ride-comparison-results.tsx – Results display with pricing comparison
components/RouteMap.tsx – Map wrapper component using dynamic imports
components/RouteMapClient.tsx – Client-side map implementation with Leaflet
components/route-header.tsx – Route display header component
components/price-alert.tsx – Price alert modal component
lib/ – Shared utilities and helper functions
lib/utils.ts – Utility functions (cn for class merging, etc.)
tests_/ – Test files organized by feature
__tests__/components/ – Component-specific tests
public/ – Static assets (manifest.json, service worker, icons)

